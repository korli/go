// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syscall
#include "runtime.h"
#include "defs_GOOS_GOARCH.h"
#include "os_GOOS.h"
#include "cgocall.h"
#include "../../cmd/ld/textflag.h"

#ifdef GOARCH_386
#define FUNC(a) ((uintptr) &a)
#else
#define FUNC(a) (a)
#endif

#pragma dynimport libc·chdir chdir "libroot.so"
#pragma dynimport libc·chroot chroot "libroot.so"
#pragma dynimport libc·close close "libroot.so"
#pragma dynimport libc·dlclose dlclose "libroot.so"
#pragma dynimport libc·dlopen dlopen "libroot.so"
#pragma dynimport libc·dlsym dlsym "libroot.so"
#pragma dynimport libc·dup2 dup2 "libroot.so"
#pragma dynimport libc·execve execve "libroot.so"
#pragma dynimport libc·fcntl fcntl "libroot.so"
#pragma dynimport libc·gethostname gethostname "libroot.so"
#pragma dynimport libc·ioctl ioctl "libroot.so"
#pragma dynimport libc·mmap mmap "libroot.so"
#pragma dynimport libc·pipe pipe "libroot.so"
#pragma dynimport libc·setgid setgid "libroot.so"
#pragma dynimport libc·setgroups setgroups "libroot.so"
#pragma dynimport libc·setsid setsid "libroot.so"
#pragma dynimport libc·setuid setuid "libroot.so"
#pragma dynimport libc·setpgid setsid "libroot.so"
#pragma dynimport libc·syscall syscall "libroot.so"
#pragma dynimport libc·fork fork "libroot.so"
#pragma dynimport libc·waitpid waitpid "libroot.so"
extern uintptr libc·chdir;
extern uintptr libc·chroot;
extern uintptr libc·close;
extern uintptr libc·dlclose;
extern uintptr libc·dlopen;
extern uintptr libc·dlsym;
extern uintptr libc·dup2;
extern uintptr libc·execve;
extern uintptr libc·exit;
extern uintptr libc·fcntl;
extern uintptr libc·gethostname;
extern uintptr libc·ioctl;
extern uintptr libc·mmap;
extern uintptr libc·pipe;
extern uintptr libc·setgid;
extern uintptr libc·setgroups;
extern uintptr libc·setsid;
extern uintptr libc·setuid;
extern uintptr libc·setpgid;
extern uintptr libc·syscall;
extern uintptr libc·fork;
extern uintptr libc·waitpid;
extern uintptr libc·write;

func sysvicall6(func uintptr, nargs uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) (r1 uintptr, r2 uintptr, err uintptr)
{
	LibCall c;

	USED(a2);
	USED(a3);
	USED(a4);
	USED(a5);
	USED(a6);
	c.fn = (void*)func;
	c.n = nargs;
	c.args = (void*)&a1;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	r1 = c.r1;
	r2 = c.r2;
}

#pragma textflag NOSPLIT
func rawSysvicall6(func uintptr, nargs uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) (r1 uintptr, r2 uintptr, err uintptr)
{
	LibCall c;

	USED(a2);
	USED(a3);
	USED(a4);
	USED(a5);
	USED(a6);
	c.fn = (void*)func;
	c.n = nargs;
	c.args = (void*)&a1;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	r1 = c.r1;
	r2 = c.r2;
}

#pragma textflag NOSPLIT
func chdir(path uintptr) (err uintptr) {
	LibCall c;

	c.fn = (void*) FUNC(libc·chdir);
	c.n = 1;
	c.args = (void*)&path;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

#pragma textflag NOSPLIT
func chroot1(path uintptr) (err uintptr) {
	LibCall c;

	c.fn = (void*) FUNC(libc·chroot);
	c.n = 1;
	c.args = (void*)&path;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

#pragma textflag NOSPLIT
func close(fd uintptr) (err uintptr) {
	LibCall c;

	c.fn = (void*) FUNC(libc·close);
	c.n = 1;
	c.args = (void*)&fd;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

func dlclose(handle uintptr) (err uintptr) {
	LibCall c;

	USED(handle);
	c.fn = (void*) FUNC(libc·dlclose);
	c.n = 1;
	c.args = (void*)&handle;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	err = c.r1;
}

func dlopen(name *uint8, mode uintptr) (handle uintptr, err uintptr) {
	LibCall c;

	USED(mode);
	c.fn = (void*) FUNC(libc·dlopen);
	c.n = 2;
	c.args = (void*)&name;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	handle = c.r1;
	if(handle == 0)
		err = c.err;
	else
		err = 0;
}

func dlsym(handle uintptr, name *uint8) (proc uintptr, err uintptr) {
	LibCall c;

	USED(name);
	c.fn = (void*) FUNC(libc·dlsym);
	c.n = 2;
	c.args = &handle;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	proc = c.r1;
	if(proc == 0)
		err = c.err;
	else
		err = 0;
}

#pragma textflag NOSPLIT
func dup2(fd1 uintptr, fd2 uintptr) (val uintptr, err uintptr) {
	LibCall c;
	USED(fd2);
	c.fn = (void*) FUNC(libc·dup2);
	c.n = 2;
	c.args = (void*) &fd1;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	val = c.r1;
	err = c.err;
}

#pragma textflag NOSPLIT
func execve(path uintptr, argv uintptr, envp uintptr) (err uintptr) {
	LibCall c;

	USED(argv);
	USED(envp);
	c.fn = (void*) FUNC(libc·execve);
	c.n = 3;
	c.args = (void*)&path;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

#pragma textflag NOSPLIT
func exit(code uintptr) {
	LibCall c;

	c.fn = (void*) FUNC(libc·exit);
	c.n = 1;
	c.args = (void*)&code;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
}

#pragma textflag NOSPLIT
func fcntl1(fd uintptr, cmd uintptr, arg uintptr) (val uintptr, err uintptr) {
	LibCall c;

	USED(cmd);
	USED(arg);
	c.fn = (void*) FUNC(libc·fcntl);
	c.n = 3;
	c.args = (void*)&fd;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	val = c.r1;
}

func gethostname() (name String, err uintptr) {
	struct { uintptr v[2]; } args;
	uint8 cname[HOST_NAME_MAX];
	LibCall c;

	c.fn = (void*) FUNC(libc·gethostname);
	c.n = 2;
	args.v[0] = (uintptr)&cname[0];
	args.v[1] = HOST_NAME_MAX;
	c.args = (void*)&args;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	if(c.r1) {
		name = runtime·emptystring;
		return;
	}
	cname[HOST_NAME_MAX - 1] = 0;
	name = runtime·gostring(cname);
}

#pragma textflag NOSPLIT
func ioctl(fd uintptr, req uintptr, arg uintptr) (err uintptr) {
	LibCall c;

	USED(req);
	USED(arg);
	c.fn = (void*) FUNC(libc·ioctl);
	c.n = 3;
	c.args = (void*)&fd;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

func wait4(pid uintptr, wstatus *uint32, options uintptr, rusage *void) (wpid int, err uintptr) {
	LibCall c;

	USED(wstatus);
	USED(options);
	c.fn = (void*) FUNC(libc·waitpid);
	c.n = 3;
	c.args = (void*)&pid;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	wpid = c.r1;
}

#pragma textflag NOSPLIT
func setgid(gid uintptr) (err uintptr) {
	LibCall c;

	c.fn = (void*) FUNC(libc·setgid);
	c.n = 1;
	c.args = (void*)&gid;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

#pragma textflag NOSPLIT
func setgroups1(ngid uintptr, gid uintptr) (err uintptr) {
	LibCall c;

	USED(gid);
	c.fn = (void*) FUNC(libc·setgroups);
	c.n = 2;
	c.args = (void*)&ngid;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

#pragma textflag NOSPLIT
func setsid() (pid uintptr, err uintptr) {
	LibCall c;

	c.fn = (void*) FUNC(libc·setsid);
	c.n = 0;
	c.args = (void*)0;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	pid = c.r1;
}

#pragma textflag NOSPLIT
func setuid(uid uintptr) (err uintptr) {
	LibCall c;

	c.fn = (void*) FUNC(libc·setuid);
	c.n = 1;
	c.args = (void*)&uid;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

#pragma textflag NOSPLIT
func setpgid(pid uintptr, pgid uintptr) (err uintptr) {
	LibCall c;

	USED(pgid);
	c.fn = (void*) FUNC(libc·setpgid);
	c.n = 2;
	c.args = (void*)&pid;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
}

#pragma textflag NOSPLIT
func forkx(flags uintptr) (pid uintptr, err uintptr) {
	LibCall c;

	c.fn = (void*) FUNC(libc·fork);
	c.n = 0;
	c.args = (void*)0;//&flags;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	pid = c.r1;
}

void runtime·pipe1(void);

func pipe() (r uintptr, w uintptr, err uintptr) {

	LibCall c;

	c.fn = (void*)runtime·pipe1;
	c.n = 0;
	c.args = (void*)0;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	r = c.r1;
	w = c.r2;
}

#pragma textflag NOSPLIT
func write1(fd uintptr, buf uintptr, nbyte uintptr) (n uintptr, err uintptr) {
	LibCall c;

	USED(buf);
	USED(nbyte);
	c.fn = (void*) FUNC(libc·write);
	c.n = 3;
	c.args = (void*)fd;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	n = c.r1;
}

// FIXME: haiku: can we fix the auto generator so we won't have to handcode this?
func mmap(addr uintptr, length uintptr, prot uintptr, flag uintptr, fd uintptr, pos int64) (ret uintptr, err uintptr) {
	LibCall c;
	USED(length);
	USED(prot);
	USED(flag);
	USED(fd);
	USED(pos);
	c.fn = (void*) FUNC(libc·mmap);
	c.n = 7;
	c.args = &addr;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	ret = c.r1;
}

func Syscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) (r1 uintptr, r2 uintptr, err uintptr) {
	//LibCall c;

	USED(a1);
	USED(a2);
	USED(a3);
	USED(trap);
	runtime·throw("Syscall not supported on Haiku");
	/*
	c.fn = (void*) FUNC(libc·syscall);
	c.n = 4;
	c.args = &trap;
	runtime·cgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	r1 = c.r1;
	r2 = c.r2;
	*/
}

func RawSyscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) (r1 uintptr, r2 uintptr, err uintptr) {
	//LibCall c;

	USED(a1);
	USED(a2);
	USED(a3);
	USED(trap);
	runtime·throw("Syscall not supported on Haiku");
	/*
	c.fn = (void*) FUNC(libc·syscall);
	c.n = 4;
	c.args = &trap;
	runtime·asmcgocall(runtime·asmsysvicall6, &c);
	err = c.err;
	r1 = c.r1;
	r2 = c.r2;
	*/
}
